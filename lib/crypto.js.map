{"version":3,"file":"crypto.js","sourceRoot":"","sources":["../src/crypto.ts"],"names":[],"mappings":";;;AAAA,iCAAiC;AACjC,uCAA2C;AAEpC,MAAM,QAAQ,GAAG,CACtB,GAAoB,EAC0C,EAAE;IAChE,GAAG,GAAG,wBAAc,CAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC;IAE7C,IAAI,OAAO,GAAG,KAAK,QAAQ;QAAE,OAAO,GAAG,CAAC;IACxC,IAAI,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,GAAG,CAAC;IAEhD,MAAM,UAAU,GAAG,GAAG,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IAEzC,IAAI,UAAU,EAAE;QACd,MAAM,UAAU,GAAG;YACjB,6BAA6B;YAC7B,GAAG,UAAU;YACb,2BAA2B;YAC3B,EAAE;SACH,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACb,OAAO,UAAU,CAAC;KACnB;IAED,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;AACjC,CAAC,CAAC;AArBW,QAAA,QAAQ,YAqBnB;AAEK,MAAM,SAAS,GAAG,CAAC,IAAY,EAAU,EAAE;IAChD,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAE1C,IAAI,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;QAAE,IAAI,GAAG,+BAA+B,GAAG,IAAI,CAAC;IAC9F,IAAI,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAAE,IAAI,GAAG,IAAI,GAAG,+BAA+B,CAAC;IAE5F,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAPW,QAAA,SAAS,aAOpB;AAEK,MAAM,gBAAgB,GAAG,GAAW,EAAE;IAC3C,OAAO,GAAG,GAAG,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AACtD,CAAC,CAAC;AAFW,QAAA,gBAAgB,oBAE3B;AAEK,MAAM,4BAA4B,GAAG,CAAC,WAAmB,EAAU,EAAE;IAC1E,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,6BAA6B,EAAE,EAAE,CAAC,CAAC;IACrE,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,2BAA2B,EAAE,EAAE,CAAC,CAAC;IACnE,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACjD,OAAO,WAAW,CAAC;AACrB,CAAC,CAAC;AALW,QAAA,4BAA4B,gCAKvC","sourcesContent":["import * as crypto from \"crypto\";\nimport { assertRequired } from \"./utility\";\n\nexport const keyToPEM = (\n  key: string | Buffer\n): typeof key extends string | Buffer ? string | Buffer : Error => {\n  key = assertRequired(key, \"key is required\");\n\n  if (typeof key !== \"string\") return key;\n  if (key.split(/\\r?\\n/).length !== 1) return key;\n\n  const matchedKey = key.match(/.{1,64}/g);\n\n  if (matchedKey) {\n    const wrappedKey = [\n      \"-----BEGIN PRIVATE KEY-----\",\n      ...matchedKey,\n      \"-----END PRIVATE KEY-----\",\n      \"\",\n    ].join(\"\\n\");\n    return wrappedKey;\n  }\n\n  throw new Error(\"Invalid key\");\n};\n\nexport const certToPEM = (cert: string): string => {\n  cert = cert.match(/.{1,64}/g)!.join(\"\\n\");\n\n  if (cert.indexOf(\"-BEGIN CERTIFICATE-\") === -1) cert = \"-----BEGIN CERTIFICATE-----\\n\" + cert;\n  if (cert.indexOf(\"-END CERTIFICATE-\") === -1) cert = cert + \"\\n-----END CERTIFICATE-----\\n\";\n\n  return cert;\n};\n\nexport const generateUniqueId = (): string => {\n  return \"_\" + crypto.randomBytes(10).toString(\"hex\");\n};\n\nexport const removeCertPEMHeaderAndFooter = (certificate: string): string => {\n  certificate = certificate.replace(/-+BEGIN CERTIFICATE-+\\r?\\n?/, \"\");\n  certificate = certificate.replace(/-+END CERTIFICATE-+\\r?\\n?/, \"\");\n  certificate = certificate.replace(/\\r\\n/g, \"\\n\");\n  return certificate;\n};\n"]}